# ☕ Java 入门

## 🏗️ Java 技术栈

+ 程序基础
+ 面向对象
+ 数组
+ 异常机制
+ 常用API
+ 集合+Map
+ IO流
+ 多线程
+ 网络编程
+ 正则表达式
+ lambda表达式 + 函数式接口
+ 反射机制
+ GUI

## 📌 Java 方向

- JavaSE
- JavaME
- JavaWEB
- JavaEE

## 🔰 Java 特性

+ 多线程
+ 跨平台
+ 面向对象
+ 自动垃圾回收

Java 属于静态强类型解释性语言

**静态类型** 创建变量时指定数据类型

**动态类型** 创建变量时无需指定数据类型 运行后赋值时确定数据类型

**强类型** 需通过强制转换类型 转换类型

**弱类型** 根据程序上下文环境自动修改数据类型

**编译型** 使用编译器来编译执行的编程语言

**解释型** 使用解释器来解释执行的编程语言

<style>
    * {
      margin: 0;
      padding: 0;
      font-family: MiSans;
    }
    #javac {
      margin-left: 60px;
      margin-right: 80px;
    }
    p{
      margin: 0;
    }
    #brand {
      margin: 0;
      margin-left: 180px;
      width: fit-content;
      border: 1px black solid;
    }
</style>
<section>
    <span id="javac">javac</span><span id="java">java</span>
    <p>xxx.java ----->xxx.class ----->Hello World</p>
    <p id="brand">Windows/Linux/MacOS</p>
</section>

+ 运行:运行时JVM开机，将所运行的类载入内存空间中的静态区
  + 加载完成后，JVM会自动调用该类的main方法(只要是方法调用，就会在栈内存中开辟栈帧并压栈)
  + 如果main方法中，有别的方法调用
    + 如果调用的是其他类中的方法，则先把对应类加载到静态区，然后再栈内存中开辟栈帧
    + 如果调用的是当前类中的方法，则直接在栈内存开辟栈帧
  + 如果被调用的方法中，还有其他方法调用，则继续开辟栈压栈，一直到栈顶元素，执行完成**弹栈** 返回上一个栈继续执行
  + 直到**main栈**帧弹栈，则整个程序生命周期终止

## 💾 结构

### 内存存储
电子位 bit 八位 一字节
<style>
    *{
      margin: 0;
      padding: 0;
      font-family: MiSans;
      box-sizing: border-box;
    }
      .bit{
      width: 40px;
      height: 40px;
      display: inline-block;
      border: 1px solid black;
    }
</style>
<div class="bit"></div><div class="bit"></div><div class="bit"></div><div class="bit"></div><div class="bit"></div><div class="bit"></div><div class="bit"></div><div class="bit"></div>

最高位为符号位

### 内存划分

### 静态区/方法区

保存静态资源文件 例如静态变量 方法 运行时的class文件等

### VM栈

以栈数据结构为模型创建的一块空间

主要用于**执行方法**

结构特征 **先进后出**

- 栈顶元素 最后放进去的元素
- 栈底元素 第一个放进去的元素
- 栈帧 栈数据结构中的元素

**压栈** 把栈帧放到栈空间的过程

**弹栈** 把栈帧在栈空间弹出去的过程

每当调用一个方法的时候，该方法就会在栈内存中开辟一个栈，并压栈到栈空间。开始执行，方法执行完后 弹栈 栈销毁

### 堆内存

保存类对象和成员变量及成员方法

## 🧾 数据类型

### 基本数据类型

- 数值型
  - 整数型
    - byte 8bit
    - short 16bit
    - int 32bit
    - long 64bit
  - 浮点型 
    - float 32bit 
    - double 64bit 
- 布尔型 boolean
- 字符型 char

 **注意** ⚠️

- byte 
  取值 `127`~-`128`
- short 
  取值 `32767`~-`32768`
- int 
  取值 `2147483647`~-`2147483648`
- long 
  需要以`L`或`l`结尾
- float 
  需要以`F`或`f`结尾
- double 
  需要以`D`或`d`结尾 或不写
- boolean
  只有 `true` 和 `false`
- char
  使用单引号表示 并且有且只有一个字符
  char 范围 `0`~`65535` 不需要负数
 支持Unicode编码 4bit 十六进制整型值 0~f  `\u0000` ~ `\uffff`

### 引用数据类型

- 类
- 数组 
- 接口

### 字符串

`\` 转义符

`+` 字符串拼接符

## 💱 类型转换

布尔型 不能参与转换

- 低精度到高精度 可以自动类型转换
- 高精度 到低精度 需要强制类型转换

### 自动类型转换

byte --> short --> int --> long --> float --> double

char --> int --> long --> float --> double

### 强制类型转换

多出的高位部分被截断 有可能损失精度

整数转换为char时 当不考虑符号位时 对应的是 `65271`

整数转换为char时 忽略负数 将响应负数的二进制转换为对应的正数 然后再进行ASCII码对照

### 多类型混合运算

当进行多类型混合运算时 结果为参与运算的最大类型

当混合运算类型只出现了 byte short int char 四种类型时

任意一种或多种进行运算 结果一定是int类型(可以理解为 混合运算 结果为参与运算的最大类型 但最低也是int类型)

## 💬 注释

单行注释
```java
// XXX
```

多行注释
```java
/*
 * XXX
 * YYY
 */
```

```java
/**
 * XXX
 * YYY
 */
```
可生成 Javadoc 文档

## 📛 命名

强制规则 只允许使用大小写字母 `$` `_` 数字 且数字不能开头 不能使用关键字和保留字

非强制规则 驼峰命名 见名之意

## 🏃 变量

### 全局变量

全局变量一般是指可以直接调用 不需要二次引用的变量

**Java 中不存在全局变量**

### 变量声明

使用**数据类型划分内存空间** 给空间取名字 并赋值

### 变量分类

分为三类
- 局部变量 在方法中写的变量
  无初始值 需初始化
- 静态变量 在类体中 使用 `static` 修饰的变量
- 成员变量 在类体中 没有使用 `static` 修饰的变量 存放在堆内存中

### 默认值

- 整数 `0`
- 小数 `0.0`
- 字符 `\u0000`
- 布尔 `false`
- 引用 `null`

### 作用域

静态变量调用 使用类名.静态变量名 需要考虑权限修饰符

### 区分

使用类名区分同名的局部变量和静态变量

使用 `this` 区分同名的局部变量和成员变量

### 优先级

局部变量可以和静态变量/成员变量**可同名**

静态变量和成员变量 **不可同名**

## 📐 运算符

### 算术运算符

### 关系运算符

`> >= < <= == !=` 结果是布尔型

`==` 基本类型比较值 引用类型比较内存地址

### 逻辑运算符

- `&` `&&` 与
  支持与运算 两边是数字 即可进行与运算
  两个数转换为二进制进行每位比较 同1取1 反之取0 结果不大于两个数中的最小数
- `|` `||` 或
- `!` 非
- `^` 异或 两边不一致为真 
   两边是数字进行异或运算 每二进制位进行比较 不同取1 相同取0
- `>>` 右移运算
  右移一次 就相当于该数除2(符号位不变)
- `>>>`
  不考虑符号位 并且不考虑正负数 只在最左边补`0` 负数有可能变正数
- `<<`  左移运算
  向左移动一位  删除左边(非符号位) 右边补`0` 相当于该数乘2

### 赋值运算符

`+=` `-=` `*=` `/=` `%=`

计算过程中自动进行强制类型转换

赋值运算 属于**右结合** 同优先级从右到左计算

```java
int result = x = y = z = 10; 
```

由于`=`的右结合性，先执行 `z = 10`; 再执行 `y = z` 再执行 `x = y` 运算

### 三目运算符

`xxx?yyy:zzz`

- `xxx` 需要判断的语句 布尔型
- `yyy` 判断为真时执行的语句
- `zzz` 判断为假时执行的语句

## 流程控制

### 分支语句

- 单分支
- 双分支
- 多分支

#### if-else

#### switch-case

```java
switch (x) {
  case y:
    zzz;
    break;
  case a:
    bbb;
    break;
  default:
    ccc;
}
```
`x` 中可传入 `byte`、`short`、`int` 或 `char` 的数据类型

从 Java SE 7 开始支持字符串 `String` 类型 同时 case 标签须为字符串常量或字面量

不加 `break` 会发生case穿透

### 循环语句

三要素

- 起始值
- 终止条件
- 步长

#### 计数循环

```java
for(起始值;终止条件;步长){

}
```

先执行起始值(只执行一次)
然后执行终止条件 为 `false` 时终止循环

#### 真假循环

```java
while(){

}
```

```java
do{

}while()
```

至少保证循环一次

### 跳转语句

- continue 跳出本次循环
- break 终止当前循环

```java
outfor:for(int i = 0; i < 5; i+ +) {
    for(int j = 0; j < 5; j++) {
      if (i == 3){
      // continue a;
      break outfor;
      }
      System.out.print(0 + " ");
    }
  System.out.println()
}
```

## 🍂 方法

一堆代码的集合 创建空间存储 并设置名字 可以通过名字找到

目的 代码复用 易维护 易扩展 更灵活

多个 修饰符

### 修饰符列表

可有可无 可以有多个(有些是不能同时出现)

多个修饰符没有先后顺序

### 权限控制

- public
- private
- protected
- 不写(默认包权限)
四选一

`static` 表示静态 不加则为成员

`final` 和 `abstract` 不能同时出现

### 返回值

#### return 作用

+ 终止方法运行
+ 将数据返回到调用处

如果无返回值 且存在return 那么此时只能终止方法运行 不会返回数据

### 类型

- 静态方法 使用 `static` 修饰
- 成员方法 没有使用 `static` 修饰
- 构造方法

### 调用

方法调用才会执行 并把结果返回给调用处

前缀.方法名(参数)

- 静态方法 类名.方法名(参数) 
  如果调用当前类中的静态方法类名可以省略
- 成员方法 对象.方法名(参数)

### 重载

方法名相同 参数列表不同(个数不同或类型不同)

### 递归

递归和迭代(循环)等价

以此类推，同时也是循环的基本思想
递归和迭代是等价的，迭代就是循环

循环可以做的，递归也能做，但是递归能做的，循环不一定能做

一般树状结构都可以遍历查询等操作
  递归需要频繁压栈弹栈，比较消耗内存，并且效率较低，所以循环能完成的，就不要使用递归
  能使用循环搞定的，就不要使用递归，除非循环搞不定
 	例如: 获取目录下所有的文件(包括子文件夹中的文件) 

比如 树状结构 目录遍历等都需要使用递归完成

需要有初始值 终止条件 步长 否则会死循环(一直压栈 不会弹栈 导致栈内存溢出)

- 直接递归
- 间接递归